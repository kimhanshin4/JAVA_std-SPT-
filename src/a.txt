- 클래스를 만듦 => main 에서 클래스를 이용해 new 키워드와 생성자 사용해 객체 생성.
        - public 접근제어자를 선언하면 어디에서도 사용할 수 있음
        - 생성자를 호출하기 위해 new 키워드 이용. => 새로운 객체 생성
        - 클래스로 만든 객체 까지도 배열로 관리 가능
        - main서 생성된 객체는 생성된 클래스의 필드변수타입, 메서드도 가지게 됨
        - ex) Main { car1.changeGear('P'); } => 생성된 클래스의 메서드 호출 => 필드 변경가능
        - 객체안에서 다뤄지는 변수와 같은 데이터들
        - ex) class {
<고유 데이터>
		String company;
                String model = "Lamborghini";
                String color ;
                double price;
<상태 데이터>
		double speed;
                char gear;
                boolean lights = true;
<객체 데이터(부품 클래스)>
        Tire tire = new Tire ();
        Door door;
        Handle handle;
        }
        - 객체를 가지고 일처리를 하기 위해 필요한 부가 개념들(상속, 호출...)
        - Class는 하위 Class를 가질 수 있다.
        - 필드에 필드 변수 선언을 하고 할당을 하지 않으면 각 타입에 따라 기본값으로 초기화된다.
        - 필드 값의 변경, 읽는 것 => 필드의 사용
        - 클래스에 필드를 정의, 선언했다고 바로 사용할 수 있는 게 아니다.
        - 인스턴스화 필요 => 객체를 생성 후 필드 사용 가능
        - 필드 접근 법
        - 외부 접근
        - Car car = new Car(); 생성 후 참조변수  car로 외부에서 객체 내부 필드에 접근 가능
        - 도트(.) 연산자 사용 => car.color = "blue";
        - 내부 접근
        - 도트 연산자를 사용, 외부에서 객체 내부 접근. 또한 객체 내부 메서드에서도 내부필드에 접근 가능
        - double brakePedal() {
        speed = 0;}
        return speed;
        }
        - =>breakPedal() 메서드 내부에서 객체 필드 바로 호출 및 사용 가능
        - void method return ( ) { } 리턴 값이 없으면 'void' / 없으면 반드시 return문이 있어야 한다.
        -  메서드가 void가 아니더라도 return문을 넣어 원하는 지점에서 메서드를 종료 할 수 있다.
        - 매개변수 : 메서드를 호출할 때 메서드로 전달하려는 값을 받기 위해 사용되는 변수
        - 해당 매개변수에 값을 전달하려면 '순서'와 '타입'을 맞춰서 넣어줘야 한다.
        - 가변길이의 매개변수 선언 가능(spread문법)
        - ex) void carSpeeds (double ... speeds) {
        for ( double v : speeds ) {
        system.out.println ("v = " + v );
        }
        }
        - 메서드를 호출한다 : 객체를 만들고 호출 객체.메서드명(매개변수)
        - 오버로딩 : 같은 이름의 메서드지만 매개변수만 다르게 받아 각각 다르게 사용하는 기능
        - 메서드의 이름이 같고, 매개변수의 개수, 타입, 순서가 달라야 한다.
        - 접근 제어자만 달라도 오버로딩 불가능
        - 메서드 이름 하나로 상황에 따른 동작 개별 정의
        - 메서드의 이름  절약
        ex)
        (1) public 'Car'(String modelName) {
        (2) public 'Car'(String modelName, String colorName) {
        (3) public 'Car'(String modelName, String colorName, double priceValue) {
        - 기본형 매개변수 : 값 자체가 복사 => 변수의 원본 값은 변경x
        - 참조형 매개변수 : 주소 값이 복사 => 원본 값이 변경됨
        - Class
        - 필드
        - 생성자 : 객체를 생성하는 방식을 정의.(생성자) => 변수를 넣은 필드를 어떻게 정의할 것인가
        - 메서드
        =>필드와 메서드를 묶어 멤버라고 한다.
        - 인스턴스 멤버 = 인스턴스 필드 + 인스턴스 메서드
        - 객체를 생성해야 사용
        - 객체의 인스턴스 필드는 각각의 인스턴스 마다 고유하게 값을 가짐
        - 객체의 메서드들은 메서드 영역에 두고 인스턴스들이 공유해서 사용
        - 단, 무조건 객체를 생성 => '인스턴스'를 통해서만 메서드가 사용될 수 있도록 제한**
        - 인스턴스 메서드도 클래스 필드 사용 가능하다.
        - 클래스 멤버 = 클래스 필드 + 클래스 메서드
        - 자바의 클래스의 로더에 의해 메서드 영역이 저장됨
        - 메서드 영역의 클래스와 같은 위치에 고정적으로 위치하고 있는 멤버 => 인스턴스화 필요 없이 바로 사용 가능
        - 클래스가 고유값을 가질 때, 변하지 않을 때
        - 선언
        - static 키워드 사용
        - 인스턴스마다 모두 가지고 있을 필요는 없는 공용적인 데이터를 저장
        - 인스턴스 필드를 사용하지 않고 실행되는 메서드가 존재한다면 static 키워드를 사용, 클래스 메서드로 선언하는 것이 좋다.
        - => 인스턴스 사용 불가 ** '3-6 0810'
        - =>필드와 메서드는 서언하는 방벙에 따라서 인스턴스, 클래스 멤버로 구분
        - 클래스 멤버 사용
        Car. company = "Audi";
        String companyName = Car.setCompany("Benz");
        - 클래스 이름과 함께 도트(,) 연산자 사용
        Car car = new Car(); // 객체 생성
        car.company = "Ferrari";
        String companyName2 = car.setCompany("Lamborghini");
        - 참조형 변수를 사용, 클래스 멤버에 접근은 가능하지만 추천 ㄴㄴ
        - 클래스 이름으로 접근하자 좋은 말 할 때
        - 지역변수 :
        - 해당 메서드가 실행 될 때마다 독립적인 값을 저장, 관리.
        - 이 메서드가 종료될 때 소멸
        - final 필드와 상수 : 최종적 => 상수 => **절대로 수정 불가능**
        - 주로 'static final classType var' => 공용적으로 쓰이고 수정 불가능
        - 관례적으로 전부 대문자로 작성 ex) NOCAMELCASE
        - 생성자 (constructor)
        - 객체가 생성될 때 호출하며 객체를 초기화 하는 역할 수행 => 사용하기 위해
        ex) public Car () { logic } // 선언
        ...
        Car car = new Car(); // 객체 생성 => 선언된 생성자의 메서드 호출
        - 기본 생성자 : 선언시 괄호() 안에 아무것도 넣지 않는 생성자.
        - 모든 클래스에 하나 이상 존재
        - 컴파일러에 의해 자동으로 생성 됨 => 생략 가능
        - 해당 클래스의 '접근제어자'를 그대로 따른다.
        - 클래스에 기본이 아닌 '일반 생성자'를 선언시, 기본 생성자가 자동으로 생성 되지 않음
        ex) public calss Car {
public Car('String model') { } // 일반 생성자 선언
        }
        => 객체 생성시
        Car car = new Car('model'); <- 넣어줘야한다.
        Car car = new Car(); <- 안됨
        - 필드 초기화
        - 인스턴스 생성 때마다 다른 값을 가져야 한다면 생성자를 통해 필드를 초기화 할 수 있다.
        - 인스턴스를 생성할 때마다 같은 기본 값을 고정해줘야 한다면, **필드에 초기값을 직접 대입**한다. => 초기화
        - this, this() : 인스턴스 자신을 가리킴
        - this
        ex) public Car (String model) {
        this.model = model; }
        - 생성자 생성시 매개변수와 객체의 필드명이 동일한 경우 this사용
        - 객체 자신을 return해야하는 메서드를 사용시
        - this() : 속한 생성자를 가져옴
        ex)
public Car (String model) {
        this (model, "Blue", 500); }
public Car (String model, String color) {
        this (model, color, 1000); }
public Car (String model, String color, double price) {
        this.model = model;
        this.color = color;
        this.price = price; }
        - 주의사항 : this()로 다른 생성자 호출시, 반드시 해당 생성자의 **첫 줄**에 작성되어야 함.
        - 제어자 : 클래스, 변수, 메서드의 선언부에 사용되어 부가적 의미 부여
        - 접근 제어자  : 클래스 내부에서 선언된 데이터 보호를 위해
        - public : 접근 제한x
        - protected : 같은 패키지 내에서 + 다른 패키지의 자손클래스에서 접근가능
        - default : 같은 '패키지' 내에서만
        - private : 같은 '클래스' 내에서만
        - 그 외 제어자 : static, final, abstract
	- 클래스, 멤버변수, 생성자에 사용되고, 지정되지 않다면 default
		- 클래스 : public, default
		- 메서드 & 멤버변수 : public, protected, default, private
		- 지역변수 : 없음
                - 생성자의 접근 제어자
                - 인스턴스의 생성 제한을 위해
                - 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치
                - 사용가능한 제어자
                - 클래스 : `public`, `default`, `final`, `abstract`
        - 메서드 : `public`, `protected`, `default`, `private`, `final`, `abstract`, `static`
        - 멤버변수 : `public`, `protected`, `default`, `private`, `final`, `static`
        - 지역변수 : `final`
        - 제어자 사용시 주의 사항**
        - 메서드에 `static`과 `abstract`를 함께 사용할 수 없다.
        - 클래스에 `abstract`와 `final`을 동시에 사용할 수 없다.
        - `abstract`메서드의 접근 제어자가 `private`일 수 없다.
        - 메서드에 `private`와 `final`을 같이 사용할 필요는 없다.
        - Getter, Setter : 거의 모든 객체를 만들 때 필수적으로 들어감
        - Getter
        - private 필드를 읽을 때 사용
        ex) private double speed;
private char gear = 'P';
private boolean lights;

public double getSpeed () {
        return model; }
public char getGear () {
        return gear; }
public boolean getLights () {
        return lights; }
        - get + 필드이름 -> camelCase로
        - 사용법 : 인스턴스 메서드 호출과 동일
        - Setter
        - private 필드를 수정할 필요가 있을 때
public double setSpeed () {
        this.model = model; }
public char setGear () {
        this.return = gear; }
public boolean getLights () {
        this.return = lights; }
        - set + 필드이름
        - 사용법 : 인스턴스 메서드 호출과 동일
        - Package & Import
        - Package : 클래스의 일부분이며, 하위 패키지를 도트(.)로 구분. -> 패키지 경로 입력
        - Import : 패키지 주소를 import해 같은 패키지에 있는 것 처럼 사용
        - 상속
        - 클래스간 관계, 상속
        - 부모가 자식에게 물려주는 행위
        - 적은 양의 코드로 새로운 클래스 작성 가능하고 공통적인 코드를 관리해 추가,변경에 용이
        - 코드 중복↓, 유지보수↑
        - 상속 : extends 키워드
        ex) public calss 자식클래스 extends 부모클래스 ( ) { }
        - 부모 클래스에 새 필드, 메서드 추가시 자식클래스는 이를 상속받아 사용.
        - 자식 클래스에 새 필드, 메서드 추가되어도 부모클래스에 영향x
        - 멤버 개수 자식클래스 >= 부모클래스
        - 사용
        - Main 메서드에서 객체 생성 후 바로 자식클래스를 생성
        - **부모클래스 객체생성 후 자식 클래스 멤버 생성,사용 불가**
        - 자식클래스 객체에서 부모클래스 멤버 사용
        - 상속과 포함
        - 상속관계 : is x
        ex) Car - SportsCar...
        - 포함관계 : has x
        ex) Car - Tire, Door, Handle...
        ex) 1 대 다수 => 가변길이 활용 => 배열 활용
        - 다중상속 : JAVA는 다중상속 지원x
        - 클래스간 복잡성
        - 자식 클래스에서 상속 받는 서로 다른 부모클래스들의 멤버들의 이름이 같다면 구별할 방법이 없음
        - final 클래스, final 메서드
        - '부모 클래스'에서 final선언 하면 '최종 클래스'가 되어 자식클래스가 사용할 수 없음
        - Object : 말그대로 “객체”를 의미하는 단어이며 보통, Object 클래스를 의미합니다.
        - Object 클래스는 Java 내 모든 클래스들의 최상위 부모 클래스 입니다.
        - 따라서, 모든 클래스는 Object의 메서드를 사용할 수 있습니다.
        - 또한 부모 클래스가 없는 자식 클래스는 컴파일러에 의해 자동으로 Object 클래스를 상속받게 됩니다.
        - Object 클래스의 메서드를 몇가지 소개
        - Object **clone()** : 해당 객체의 복제본을 생성하여 반환함.
        - boolean **equals(Object object)** : 해당 객체와 전달받은 객체가 같은지 여부를 반환함.
        - Class **getClass()** : 해당 객체의 클래스 타입을 반환함.
        - int **hashCode()** : 자바에서 객체를 식별하는 정수값인 해시 코드를 반환함.
        - String **toString()** : 해당 객체의 정보를 문자열로 반환함. & Object 클래스에서는 클래스이름 @해쉬코드값 리턴함.
        - …
        - 오버라이딩
        - 부모클래스로부터 상속받은 메서드의 내용을 재정의
        - 선언부가 부모클래스의 메서드와 일치해야함
        - 접근 제어자를 부모클래스의 메서드 보다 좁은 범위로 변경x
        - 예외는 부모클래스의 메서드 보다 많이 선언 가능
        - super와 super()
        - super : 부모 클래스의 멤버를 참조할 수 있는 키워드
        - 객체 내부 생성자 및 메서드에서 부모클래스의 멤버에 접근하기 위함
        - this, this()와 사용법 비슷
        - 다형성 : 부모타입 변수 = 자식타입객체; => 자동으로 부모타입으로 변환
        - 여러가지 형태를 가질 수 있는 능력
        - 자식객체는 부모객체의 멤버 상속 => 부모와 같이 취급
        - 자식객체 생성시 변수에 부모 클래스 타입을 적으면 그대로 형변환
        ex) mammal.swimming(); //오류
        => 부모 클래스에 swimming이 선언되있진 않기에 그대로 사용은 불가능
        ex) Whale whale = new Mammal(); //오류
        =>부모객체를 생성시 변수에 자식클래스 타입 사용 불가능
        - 강제 타입변환
        - 부모타입객체는 자식타입 변수로 자동 타입변환되지 않는다.
        - =>(자식타입), 타입변환 연산자를 사용해 강제 자식타입으로의 형변환
        ex)Whale whale = (whale) mammal;
        whale.swimming
        - 자동형변환이 완료된 변수들만 활용 가능
        - instanceof
        - 다형성 기능으로 해당 클래스 객체의 본 클래스명을 체크하는 것이 필요할 때 사용하는 명령어
        - (대상 객체) instance of (클래스 이름) => 응답값 boolean으로
        - 추상 클래스 : 미완성된 설계도, 구체적인 여러 클래스들을 일반화된 개념으로 묶음
        - 미완성된 설계도를 가진 부모클래스를 자식클래스가 이어받아 완성
        - abstract 키워드 사용
        ex) public abstract calss 추상클래스명 {
abstract 리턴타입 메서드이름(매개변수, ...);
        }
        - 추상 클래스는 추상 메서드를 포함 가능
        - 추상 메서드가 없어도 추상 클래스로 선언 가능
        - 추상 클래스는 자식클래스에 상속되어 자식 클래스에 의해서만 완성 가능
        - 추상클래스는 여러 자식 클래스들에서 공통적 필드나 메서드를 추출해서 만들 수도 있음
        - **상속받은 클래스에서 추상 클래스의 추상 메서드는 반드시 오버라이딩 되어야 한다.**=>'interface'와 연관
        - 인터페이스 interface : 여러 클래스들을 행위적 일관성으로 묶음
        - 두 객체를 연결해주는 다리 역할
        ex)사람, 삼성, 엘지티비 객체
        - 사람 객체는 멀티 리모컨 인터페이스로 삼성, 엘지 티비 양 쪽 모두 사용
        - interface 키워드 사용
        ex) public interface 인터페이스명 {
    //추상 메서드 오버라이딩
    @Override
    public 리턴타입 메서드이름(매개변수, ...)
    //실행문
}
	- 모든 멤버변수는 public static final 이어야 한다.
        - 생략 가능 => 컴파일러 자동 추가
        - 모든 메서드는 public abstract 이어야 한다.
        - 생략 가능. static, default 메서드 예외 => 구현 부분이 있어야 함
        - 구현
        - 추상클래스와 마찬가지로 직접 인스턴스를 생성할 수 없기 떄문에 클래스에 구현되어 생성
        - implements 키워드 사용해 받아서 인터페이스 구현
        - **인터페이스의 '추상 메서드'는 구현시 반드시 오버라이딩 되어야 함**
        - 만약 인터페이스의 추상 메서드를 일부만 구현해야 하면, 해당 클래스를 추상 클래스로 변경
        - 인터페이스간의 상속 가능
        - implements가 아니라 extends키워드 사용
        - 인터페이스는 다중 상속 가능
        - default 메서드와 static 메서드
        - default 메서드 : 추상 메서드의 기본적인 구현을 제공
        - 메서드 앞에 default 키워드 + 블럭{} 존재
        - 접근제어자가 public => 생략 가능 => 컴파일러 자동생성
        - 추상 메서드가 아니기 때문에 인터페이스의 구현체들에서 필수로 default 라고 재정의 할 필요 없이 바로 사용 가능
        - static 메서드 : static 특성 그대로 인터페이스에서 또한 객체 없이 호출 가능.
        - 선언
        - 다형성
        - 자동 타입변환
        - 인터페이스 변수 = 구현객체; => 자동으로 타입 변환
        - 인터페이스의 다형성
        -